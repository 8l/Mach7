   DSL 2011Bordeaux, France 2011 [to be supplied] 
   Technical Report Y.Solodkyy, G.Dos Reis, B.Stroustrup: Pattern Matching for C++  your visit, Jim, is not acceptable anymore
   Yuriy Solodkyy
   Gabriel Dos Reis
   Bjarne Stroustrup Texas A&M University
   Texas, USA {yuriys,gdr,bs}@cse.tamu.edu
  Pattern Matching for C++
   6/20/2011
   Abstract
    Pattern matching has been known in functional programming community as an abstraction mechanism that greatly simplifies the code. Following the success of functional languages, several imperative programming languages had introduced pattern matching into them. While this is relatively easy to do a-priori, when designing a new language, this might become quite a challenge to do a-posteriori when trying to introduce it into an industry strength language like C++. We present ML-like pattern matching for C++ implemented as a pure library in a form of Domain Specific Language built on top of standard C++. Our solution comes very close in terms of performance to its de facto contender – the visitor design pattern, traditionally used in pattern matching scenarios in C++. Unlike the visitor pattern, our solution is non-intrusive, open to new classes, avoids the control inversion and is much more concise, easier to read, maintain and comprehend. It also mimics many of the pattern matching facilities (e.g. guards and n+k patterns) available in other languages on the first class basis, letting us experiment with them without any changes to the compiler, while offsetting the semantic discussions that typically go along into the domain of concepts. 
CR-numbersubcategorythird-level
   Languages, Design
Key words:	P
Pattern Matching, Visitor Design Pattern, Expression Problem, C++
1  Introduction
Pattern matching is an abstraction supported by many programming languages, which allows the user to describe in a breve manner a (possibly infinite) set of values accepted by the pattern. Pattern represents effectively a predicate on values, and is usually expected to be much more consciese and readable than the equivalent predicate spelled out directly.
   Popularized by functional programming community, most notably Hope[4], ML[25], Miranda[37] and Haskell[16], for providing syntax very close to mathematical notations, pattern matching has since been making its way into many imperative programming languages like Pizza[27], Scala[26], Fortress[33], Java[20, 18], C++[19], C[1] and others. While this is relatively easy to do a-priori when designing a new language, the introduction of pattern matching into an industry strengths language a-posteriori might become a challenge. The obvious utility of the feature may be overshadowed by the complications in the language semantics necessary to make pattern matching work with other features of the language. A prototype implementation will likely require a lot of effort, but will be hard to publish due to lack of novelty.
   To balance the utility and effort we follow the approach of Semantically Enhanced Library Languages[36], under which one should rather consider subsetting a general-purpose programming language (C++ in our case), extended with a tool support (which would be convenient, but not necessary here). Such approach will typically not give you 100% of functionality, but instead would rather give you 80% of it at 20% of the time. This was exactly the case with our solution as instead of typical half a year to get any major feature implemented on a scale of C++ language, it took us less than a month to implement it as a SELL and under a week to rewrite an existing application using it.
   Naturally, a library only solution might have limitations that can be overcome in a language solution, which is why we do not propose our current approach as the ultimate library solution, but instead as a transition facility, that lets users experiment with pattern matching in C++ while letting us experiment with and eventually shape the language solution. The library only solution exposes all the functionality that will eventually be available through compiler.
   To give a quick taste of what our library enables, let us look at an example from the domain where pattern matching is known to cut the edge of brevity and readibility – compiler construction. Imagine a simple language of expressions:

OCaml data type describing this grammar as well as simple evaluator of expressions in it can be declared as following:

The corresponding C++ data types are slightly more verbose, though the only reason we have not parameterized them was to keep the example simple.

Together with evaluator, they form an instance of the Interpreter Design Pattern[12]. Unlike the type definitions, the evaluator for the language, implemented on top of our pattern matching library is almost as laconic as its version in OCaml:

The only definitions we omitted here that prevent the example from being fully functional are the mappings of class members to corresponding binding positions. We list them here for completeness, while their meaning will be explained later in section . Here we would like to mention though that these definitions are only needed to support the variables binding and not the type switching functionality of the Match.

The above syntax is enabled without any external tool support using new C++0x features[15], template meta-programming and macros. As we show in section 4, it runs up to 80% faster (depending on the usage scenario, compiler and underlain hardware) than a similar code crafted with the Visitor Design Pattern.
1.1  Motivation
The ideas and the library presented here originated from our rather unsatisfactory experience in working with various C++ front-ends and program analysis frameworks developed in C++[31, 22, 2, Lise]. The problem was not in the frameworks per se, but in the fact that we had to use Visitor Design Pattern[12] to inspect, traverse and elaborate abstract syntax trees of their target languages. Having written enough visitors to realize how unsuitable they were for the job, we started looking for other mechanisms to work with abstract syntax trees, even if they would have turned out to be significantly slower. Presence of dynamic casts in many places, often nested, to answer simple structural questions without having to resort to visitors, was a strong indicator that even though visitors were fast, in many non-critical cases users preferred shorter, cleaner and a more clear code to performance. The usage of dynamic_cast in those cases resembled the use of pattern matching in functional languages to unpack algebraic data types. Functional languages have been long known to be very suitable for developing program analysis tools because of the brevity with which the necessary algorithms can be expressed. This is why our initial goal was to develop a domain-specific library within C++ that would enable us to express various predicates on tree-like structures with the laconism of functional languages.
1.2  Visitor Design Pattern
Visitor Design Pattern[12] was devised to solve a problem of extending existing classes with new functions in object-oriented languages. Consider the above Expr example and imagine we would like to provide a pretty printing of expressions. A typical object-oriented approach would be to introduce a virtual function virtual void print() const = 0; inside the abstract base class Expr, which will be implemented correspondingly in all derived classes. This works well as long as we know all the required operations on the abstract class in advance. Unfortunately, this is very difficult to achieve in reality as the code evolves, especially in production environment. To put this in context, imagine that after the above interface with pretty printing functionality has been deployed, we decided that we need a similar functionality that saves the expression in XML format. Adding new virtual function implies modifying the base class and creating a versioning problem with the code that has been deployed already using the old interface.
   To alleviate this problem, Visitor Design Pattern separates the commonality of all such future member-functions from their specifics. The former deals with identifying the most specific derived class of the receiver object, known to the system at the time the base class was designed. The latter provides implementation of the required functionality once the most specific derived class has been identified. The interaction between the two is encoded in the protocol that fixes visitation interface enumerating all known derived classes on one side and a dispatching mechanism that guarantees to select the most specific case with respect to the dynamic type of the receiver in the visitation interface. An implementation of this protocol for our Expr example might look as following:

Note that even though implementations of accept member-functions are syntactically identical, a different visit is called. We rely here on the overload resolution mechanism of C++ to pick the most specialized visit member-function applicable to the static type of *this. This mere code maintenance convenience unfortunately, often confuses novices on what is going on. We thus would like to point out that member-functions in the visitation interface are not required to be called with the same name, – we could have equally well called them visit\s\do5(v)alue, visit\s\do5(p)lus etc. making the corresponding changes to calls inside Value::accept, Plus::accept etc.
   A user can now implement his new functions similarly to the following function to convert expressions to string:

Function eval we presented above as well as any new function that we would like to add to Expr can now be implemented in much the same way, without the need to change base interface. This flexibility does not come for free though and we would like to point out some pros and cons of this solution.
   The most important advantage of the visitor design pattern is possibility to add new operations to the class hierarchy without the necessity to change the interface each time. It’s second most quoted advantage is typically speed – the overhead of two virtual function calls incurred by the double dispatch present in the visitor design pattern is often negligable on the modern architectures. There are quite a few disadvantages however.
   The increased amount of boilerplate code that has to be added to support the above solution cannot go unnoticed. Several entities had to be forward declared because of the mutual recursivity of their definitions. The solution is specific to hierarchy, as we had to declare a visitation interface specific to the base class. It is also intrusive since we had to inject syntactically the same definition of accept method into every class participating in visitation. The amount of the necessary support increases, as additional arguments have to be passed into the visitor to be available during the visitation. This aspect can be seen in the example  where we have to store both functors inside the visitor.
   More importantly, visitors hinder extensibility of the class hierarchy: new classes added to the hierarchy after the visitation interface has been fixed, will be treated as their most derived base class present in the interface. A solution to this problem has been proposed in the form of Extensible Visitors with Default Cases[41, §4.2], however the solution, after remapping it onto C++, has problems of its own. The visitation interface hierarchy can easily be grown linearly (adding new cases for the new classes in the original hierarchy each time), but independent extensions by different authorities require developer’s intervention to unify them all, before they can be used together. This may not be feasible in environments that use dynamic linking. To avoid writing even more boilerplate code in new visitors, the solution would require usage of virtual inheritance, which typically has an overhead of extra memory dereferencing. On top of the double dispatch already present in the visitor pattern, the solution will incur two additional virtual calls and a dynamic cast for each level of visitor extension. Additional double dispatch is incurred by forwarding of default handling from base visitor to a derived one, while the dynamic cast is required for safety and can be replaced with a static case when visitation interface is guaranteed to be grown linearly (extended by one authority only). Yet another virtual call is required to be able to forward computations to subcomponents on tree-like structures to the most derived visitor. This last function lets one avoid the necessity of using heap to allocate a temporary visitor through the Factory Design Pattern[12] used in Extensible Visitor solution originally proposed by Krishnamurti, Felleisen and Friedman[17].
   Once all the boilerplate related to visitors has been written and the visitation interface has been fixed we are still left with some annoyances incurred by the pattern. One of them is the necessity to work with the control inversion that visitors put in place. Because of it we have to save any local state and any arguments that, some of the visit callbacks might need from the calling environment. Similarly, we have to save the result of the visitation, as we cannot assume that all the visitors that will potentially be implemented on a given hierarchy will use the same result type. Using visitors in a generic algorithm requires even more precautions. We summarize these visitor-related issues in the following motivating example, followed by an illustration of a pattern matching solution to the same problem enabled with our library.
1.3  Motivating Example
While comparing generic programming facilities available to functional and imperative languages (mainly Haskell and C++), Dos Reis and Jarvi present the following example in Haskell describing a sum functor[8]:

In simple words, the function eitherLift above takes two functions and an object and depending on the actual type constructor the object was created with, calls first or second function on the embedded value, encoding the result correspondingly.
   Its equivalent in C++ is not as straightforward. The idiomatic handling of discriminated unions in C++ typically assumes use of the Visitor Design Pattern[12].

The code above defines the necessary parameterized data structures as well as a correspondingly parameterized visitor class capable of introspecting it at run-time. The authors agree with us “The code has a fair amount of boilerplate to simulate pattern matching...” The actual implementation of lift in C++ now amounts to declaring and invoking a visitor:

The same function expressed with our pattern matching facility seems to be much closer to the original Haskell definition:

It is also as fast as the visitor solution, but unlike the visitors based approach neither requires EitherVisitor class anymore (together with forward declarations it needed), nor any of the accept member-functions injected in all three classes. We do require binding definitions though to be able to bind variables x and y: 1

Note that these binding definitions are made once for all possible instantiations with the use of partial template specialization in C++.
1.4  Summary
The contributions of the paper can be summarized as following:
•	We present a technique that can be used to implement type switching effectively based on the run-time type of the argument. 
•	The technique outperforms its de facto contender – visitor design pattern without sacrificing extensibility. 
•	It works in the presence of multiple inheritance, including repeated and virtual inheritance as well as in generic code. 
•	The technique generalizes to other object-oriented languages that use virtual tables to implement dynamic dispatch. 
•	We present a functional style pattern matching for C++ built as a library employing the above technique. 
•	The solution is open, non-intrusive and can be applied to any class hierarchy retroactively. 
•	It allows one to avoid the control inversion typical for visitors. 
•	We provide performance and ease of use comparison based on real code. 
The novelty of the paper lays in a new method that can be used by compilers of object-oriented languages as well as libraries written in them to implement type switching, type testing, pattern matching and multiple dispatch efficiently. We look at different approaches that are taken in implementing algebraic data types in C++ today and present a unified pattern matching syntax that works uniformly with all of them. We also generalize Haskell’s n+k patterns to any invertible operations. Semantics issues that typically accompany n+k pattern are handled transparently by forwarding the problem into the concepts domain, thanks to the fact that we work in a library setting. A practical benefit of our solution is that it can be used right away with any compiler with a descent support of C++0x without requiring to install any additional tools or preprocessors.
   The rest of this paper is structured as following. In Section 2, we present evolution of pattern matching in different languages, presenting informally through example commonly used terminology and semantics of various pattern matching facilities. Section 3 presents various approaches that are taken in C++ to implementing algebraic data types as well as demonstrates uniform handling of them in our pattern matching library. Section ? discusses the v-table caching technique that made the efficient implementation of pattern matching possible, while Section 4 provides performance evaluation of this technique against common alternatives. Section 6 discusses some related work, while Section 8 concludes by discussing some future directions and possible improvements.
2  Background
Pattern matching in the context of a programming language was first introduced in a string manipulation language SNOBOL[11]. Its fourth reincarnation SNOBOL4 had patterns as first-class data types providing operations of concatenation and alternation on them[13]. The first reference to a pattern matching construct that resembles the one found in statically typed functional languages today is usually attributed to Burstall and his work on structural induction[3].
   In the context of object-oriented programming, pattern matching has been first explored in Pizza programming language[27]. These efforts have been continued in Scala[26] and together with notable work of Burak Emir on Object-Oriented Pattern Matching[10] have resulted in incorporation of pattern matching into the language.
   Pattern matching has been closely related to algebraic data types and equational reasoning since the early days of functional programming. In languages like ML and Haskel an Algebraic Data Type is a data type each of whose values is picked from a disjoint sum of (possibly recursive) data types, called variants. Each of the variants is marked with a unique symbolic constant called constructor. Constructors provide a convenient way of creating a value of its variant type as well as a way of discriminating its variant type from the algebraic data type through pattern matching.
   Algebraic data type expr from Section 1 consists of 5 variants, marked with constructors Value, Plus, Minus, Times and Divide respectively. Constructor Value expects a value of type int during construction, as well as any pattern that admits values of type int during decomposition through pattern matching. Similarly, the other four constructors expect a value of a Cartesian product of two expr types during construction, as well as any pattern that would admit a value of such type during decomposition.
   Algebraic data types can be parameterized and recursive, as demonstrated by the following Haskell code that defines a binary tree parameterized on type k of keys and type d of data stored in the nodes:

Naturally, they can be decomposed in a generic algorithm like the function find below, defined through case analysis on the tree’s structure:

The set of values described by a given algebraic data type is defined inductively as the least set closed under constructor functions of its variants. Algebraic data types draw their name from the practice of using case distinction in mathematical function definitions and proofs that involve algebraic terms.
   One of the main differences of algebraic data types from classes in object-oriented languages is that an algebraic data type definition is closed because it fixes the structure of its instances once and for all. Once we have listed all the variants a given algebraic data type may have we cannot extend it with new variants without modifying its definition. This is not the case in object-oriented languages, where classes are open to extension through subclassing. 
   Closeness of algebraic data types is particularly useful in reasoning about programs by case analysis and allows the compiler to perform an automatic incompleteness check – test of whether a given match expression covers all possible cases. A related notion of redundancy checking arises from the tradition of using first-fit strategy in pattern matching. It warns the user of any case clause inside a matching expression that will never be entered because of preceding one being more general. Object-oriented languages, especially C++, typically prefer best-fit strategy (e.g. for overload resolution and class template specialization) because it is not prone to errors where semantics of a statement might change depending on the ordering of preceding definitions. The notable exception in C++ semantics that prefers the first-fit strategy is ordering of catch handlers of a try-block. Similarly to functional languages the compiler will perform redundancy checking on catch handlers and issue a warning that lists the redundant cases.
   The patterns that work with algebraic data types we have seen so far are generally called tree patterns or data constructor patterns. Special cases of these patterns are list patterns and tuple patterns. The former lets one split a list into a sequence of elements in its beginning and a tail with the help of list constructor : and an empty list constructor [] e.g. [x:y:rest]. The latter does the same with tuples using tuple constructor („...,) e.g. ([x:xs],’b’,(1,2.0),"hi",True).
   Pattern matching is not used solely with algebraic data types and can equally well be applied to built-in types. The following Haskell code defines factorial function in the form of equations:

Here 0 in the left hand side of the first equation is an example of a value pattern (also known as constant pattern) that will only match when the actual argument passed to the function factorial is 0. The variable pattern n (also referred to as identifier pattern) in the left hand side of the second equation will match any value, binding variable n to that value in the right hand side of equation. Similarly to variable pattern, wildcard pattern \s\do5() will match any value with the exception that the matched value will not be bound to any variable. Value patterns, variable patterns and wildcard patterns are generally called primitive patterns. Patterns like variable and wildcard patterns that never fail to match are called irrefutable, in contrast to refutable patterns like value patterns, which may fail to match.
   In Haskell 98[16] the above definition of factorial could also be written as:

The (n+1) pattern in the left hand side of equation is an example of n+k pattern. Accordingly to its informal semantics “Matching an n+k pattern (where n is a variable and k is a positive integer literal) against a value v succeeds if v?k, resulting in the binding of n to v?k, and fails otherwise”[29]. n+k patterns were introduced into Haskel to let users express inductive functions on natural numbers in much the same way as functions defined through case analysis on algebraic data types. Besides succinct notation, such language feature could facilitate automatic proof of termination of such functions by compiler. Peano numbers, however, used as an analogy to algebraic data type representation of natural numbers, is not always the best abstraction for representing other mathematical operations. This, together with numerous ways of defining semantics of generalized n+k patterns were some of the reasons why the feature was never generalized to other kinds of expressions, even though there were plenty of known applications. Unfortunately, numerous debates over semantics and usefulness of the feature resulted in n+k patterns being removed from the language altogether in Haskell 2010 standard[9].
   While n+k patterns were something only Haskell and Hope had, another common feature of many programming languages that have pattern matching are guards. A guard is a predicate attached to a pattern that may make use of the variables bound in it. The result of its evaluation will determine whether the case clause and the body associated with it will be accepted or rejected. The following OCaml code for exp language from Section 1 defines the rules for factorizing expressions  into  and  into  with the help of guards spelled out after keyword when:

One may wonder why could not we simply write the above case clause as Plus(Times(e,e2), Times(e,e4)) to avoid the guard?  Patterns that permit use of the same variable in them multiple times are called equivalence patterns, while the requirement of absence of such patterns in a language is called linearity. Unfortunately, neither OCaml nor Haskell support such patterns. Miranda[37] is one of the languages that permit them. 
   The example above illustrates yet another common pattern matching facility – nesting of patterns. With a simple expression in the case clause we define a predicate that tests the top-level expression to be tagged with a Plus constructor, while both of its arguments to be marked with Times constructor, binding their arguments (or potentially pattern matching further) respectively. Note that the visitor design pattern does not provide this level of flexibility and each of the nested tests might have required a new visitor to be written. Nesting of patterns like the one above is typically where users resort to type tests and type cast that in case of C++ can be combined into a single call to dynamic\s\do5(c)ast.
   Related to nested patterns are as-patterns that help one take a value apart while still maintaining its integrity. The following rule could have been a part of a hypothetical rewriting system in OCaml similar to the one above. Its intention is to rewrite expressions of the form  into .

We introduced a name “numerator” as a synonym of the result of matching the entire sub-expression Divide(\s\do5(,)e2) in order to refer it without recomposing in the right-hand side of the case clause. We omitted the conjunction of relevant non-zero checks for brevity, one can see that we will need access to e2 in it however.
   Decomposing algebraic data types through pattern matching has an important drawback that was originally spotted by Wadler[40]: they expose concrete representation of an abstract data type, which conflicts with the principle of data abstraction. To overcome the problem he proposed the notion of views that represent conversions between different representations that are implicitly applied during pattern matching. As an example, imagine polar and cartesian representations of complex numbers. A user might choose polar representation as a concrete representation for the abstract data type complex, treating cartesian representation as view or vice versa:2

The user might than choose to implement operations in whatever representation is the most suitable, while the compiler will implicitly convert representation if needed:

The idea of views were later adopted in various forms in several languages: Haskell[5], Standard ML[28], Scala[10] in the form of extractors and F?[7] under the name of active patterns.
   Logic programming languages like Prolog take pattern matching to even greater level. The main difference between pattern matching in logic languages and functional languages is that functional pattern matching is a “one-way” matching where patterns are matched against values, possibly binding some variables in the pattern along the way. Pattern matching in logic programming is “two-way” matching based on unification where patterns can be matched against other patterns, possibly binding some variables in both patterns and potentially leaving some variables unbound or partially bound – i.e. bound to patterns. A hypothetical example of such functionality can be matching a pattern Plus(x,Times(x,1)) against another pattern Plus(Divide(y,2),z), which will result in binding x to a Divide(y,2) and z to Times(Divide(y,2),1) with y left unbound, leaving both x and z effectively a pattern.
3  Pattern Matching for C++
Interestingly enough C++ has a pure functional sublanguage in it that has a striking similarity to ML and Haskell. The sublanguage in question is template facilities of C++ that has been shown to be Turing complete[39]. In fact, there were attempts to use Haskell as a pseudo code language for template metaprogramming in C++[23]. A key observation in this analogy is that partial and explicit template specialization of C++ class templates is similar to defining equations for Haskell functions. Consider as an example the above factorial function expressed in terms of compile-time pattern matching facilities of C++:

Coincidentally, we use this compile-time pattern matching facility as a meta-language to implement its run-time counterpart.
   A place where C++ does have a primitive run-time pattern matching is the catch clause of exception handling. The order of clauses matters, which is similar to the order of patterns. 
3.1  Algebraic Data types in C++
Functional programming community algebraic data type (sometimes also called a variant type[1]) is a data type each of whose values is data from other data types wrapped in one of the constructors of the data type. Any wrapped datum is an argument to the constructor. In contrast to other data types, the constructor is not executed and the only way to operate on the data is to unwrap the constructor using pattern matching.
   There are at least 3 different ways to represent them in C++ We unify syntax 
   An ML data type of the form 

Can be encoded in C++ in at least the 4 following ways:
   The important difference between algebraic data types and classes in C++ is that algebraic data types are closed and once constructors have been defined, no new constructors can be added. C++ classes on the other hand are always open: user may extend any class with a new constructor. Work on extensible data types exist[14, 21]
   The result of invoking match<T>(a,b,c) is a pattern that can be applied to a given instance of any type U, that is related by inheritance to T (i.e. is a base of, derived from or a sibling of). Applying given pattern to an instance returns a pointer to type T if matching succeeds along with binding all the variables and subexpressions the pattern was created with.
   ---------------
   Similarly to Haskell, we employ first-fit pattern matching under which the equations are matched linearly from top to bottom. This is why putting Otherwise() not at the end of the switch statement will effectively close all subsequent equations.
   We first present informally the pattern matching facilities our library exposes.
   Let’s assume we have a simple class hierarchy of shapes:

Before the library can be used, the user has to provide decomposition into a tuple of all the data structures against which pattern matching will be performed. This is done through specializing traits-like class match_members:

The first argument of CM represent a position, while the second argument represents the member of the class that will be matched against in that position. Members don’t have to be data members only, but can also be nullary member functions providing access to given subcomponent (as Circle::get_center above). With these definition we can write our first function using pattern matching.

Unfortunately we have to predeclare variables as we are in a library setting and cannot change the compiler, while C++ requires all the variables to be forward declared. The binding of variables though works exactly as in other languages. One may have noticed that the wildcard has to be predeclared as well. This is not required as the library may provide a global variable with such name, we just wanted to mention here that the name of the meta variable may be arbitrary, it is its type that triggers the proper matching behavior.
   TODO: Discuss exceptions while accessing members
   We note that our approach is not limited to handling only these specific representations of algebraic datatypes in C++, but can be applied to any class hierarchy, viewing patternm matching as a generalization of dynamic_cast.
3.2  Guards
The following pattern will match circles with any center but only those whose radius is greater than 3 and smaller than 5. The value of the radius of such matching Circle will be bound to r.

The expression in the guard can be arbitrarily complicated and unlike the pattern itself, the variables might be mentioned several times as by the time the guard is going to be evaluated, the variable will be bound. The —= operator that defines the guard was chosen arbitrarily from those that have pretty low precedence in C++ in order to allow most of the other operators be used in the condition part (right hand side) without parenthesis. The variable in the left hand side of the guard operator is the one that will be bound by the pattern. The condition part of the guard may include only this variable and the variables bound in preceeding positions. For example:

This code will effectively match circles with the center on the line y=x. Note that the more straitforward notation:

is invalid in most of the languages as it uses the same variable twice in the binding position. This can be given a semantics that the first use is the binding use, while the second one is the use as a bound value, but one would have to argue it won’t lead to confusion and mistakes in more complicated expressions.
   The important bit about our implementation of guards is that variables used in guards have to be explicitly wrapped into variable<> template in order to let the library build the corresponding expression template. The convenient notion that allowed us to use normal variables inside matches seen before will not work for guards as the expression would simply be evaluated using the C++ semantics and the resulting value will be passed to the match function as the value (and not the expression) we would like to match against.
   We chose to provide syntax for guards directly in binding expressions in order to make sure we can determine certain pattern doesn’t match as soon as possible and thus not have to compute matching for subsequent arguments. An alternative syntax for guards used in other languages is after the entire match expression, using traditional predicates.
3.3  The (in)famous n+k patterns
Similarly to Haskell (until 2010), we provide support for the n+k patterns. With them one can define factorial in the following way:

Unlike Haskell however, our patterns are not limited n+k form only and are generalized to any invertible operations. The definition of fast algorithm that computes x to the power of n can be written as following in the library:

Another typical example that appears in the context of discussions about generalizing n+k patterns in Haskell is fast fibbonaci algorithm given below:

Interestingly enought instead of generalization, the n+k patterns were made obsolete in Haskell as of 2010[HaskelDocMakingThis]. This was result of many discussions trying to provide semantics to them in the context of user defined types. Here, we are not claiming to solve the relevant discussions, but instead are making sure that our solution is transparent in such a way that we can use the C++0x forthcoming concept mechanism to deal with relevant issues. In particular when having a generalized n+k pattern on variable<T> we try to make sure that 
   Scala uses a very stylistic approach to disambiguating variables that need to be bound from named constants. In particular they require that named constants start with capital letter while variables start with lowercase letter[EmirPhd, §2.8]. While such a requirement is inline with similar requirements for naming a constructor in various functional languages, this will raise eyebrowse in C++. We thus form our distinction between variables to be bound and values to be matched based on type of the expression: expressions that will bind to a reference type are assumed to be used as variables that have to be bound; expressions that will only bind to const reference are assumed to be values that have to be matched instead, even if they are named.
3.4  Views
Our extractors are similar to extractors in Scala, which in turn resemble Views proposed for Haskell.
   TODO: Add discussion of pattern matching in generic code.
   Our notion of layout is similar to Wadler’s notion of Case class
   Discuss layouts as a way of handling pattern matching for cases of multiple inheritance.
4  Evaluation
In this section we evaluate the performance of our solution in comparison to the de facto standard – visitor design pattern.
   To evaluate the performance of our solution we’ve taken a working piece of code that operates visitor pattern on a fairly large class hierarchy and reimplemented it using pattern matching.
   Preliminary evaluation results obtained on synthetic examples are as following:
   As long as dynamic cast doesn’t have to be invoked (e.g. we do n+k patterns or guards, the overhead is reasonable and is between 15 and 30 persent.
   As soon as dynamic cast has to be used inside the match, the overhead easily becomes 10 times slower than visitor’s single virtual function call. Because of sequential order of tests, the overhead for classes tested later becomes significant, effectively requiring the user to prioritize the order of tests.
5  Discussion
We considered using smaller types for storing line numbers based on our observation that we haven’t found many C++ source files that had more than 65535 lines. This was saving us space for hash tables but resulted in worse performance due to access of smaller words from memory.
   We also looked into storing differences between switch’es head line number and case’s line number, following the observation that very occasionaly we saw more than 256 cases in a pattern matching switch. This also degraded performance so we did not use it.
   We would like to note that in presence of deeper hierarchy, visitors often implement members by forwarding call to their base, which may incure additional overhead.
6  Related Work
A good survey of work on general pattern matching can be found in in a term project paper by Miller[24].
   Great overview of pattern matching in Scala compared to several other languages is presented in[32].
   Prop was an attempt to add pattern matching together with algebraic datatypes and other functional features into C++[19].
   JMatch was a similar incentive to add pattern matching to Java.
   Sankel provides a good educational overview of how algebraic datatypes can be implemented in C++[35, 34]. 
   Emir’s PhD thesis provides an extensive analysis of pattern matching in the context of object-oriented languages[10].
   Cook et al used expression templates to implement a query language to Pivot’s IPR[6]. The principal difference of their work from this work is that authors were essentially creating a pattern matcher for a given class hierarchy and thus could take the semantics of the entities represented by classes in the hierarchy into account. Our approach is parametrized over class hierarchy and thus provides a rather lower level pattern matching functionality that lets one simplify work with that hierarchy. One can think of it as a generalized dynamic_cast.
   In his dissertation, Pirkelbauer provides a different pattern matcher against Pivot’s IPR[30].
   Veldhuizen discovered a very powerful technique called Expression templates[38].
   Other languages that use pattern matching include: ...
   Dos Reis et al compares functional and imperative approaches to generic programming and discusses the role of pattern matching in expressing generic algorithms in the functional approach[dos\s\do5(r)eis\s\do5(0)5\s\do5(w)hat\s\do5(i)s\s\do5(g)p]. They also demonstrate with an elegant example the amount of boilerplate code necessary to write in C++ in order to describe a sum-functor.k
   Boost::proto is a library for creating DSL using expression templates.
   TOM is a pattern matching compiler that adds pattern matching facilities to imperative languages such as C, Java, or Eiffel.[1]
7  Future Work
Describe formally concepts used in our expression templates.
   Find better recursive patterns for sequences.
   Make patterns more reusable by eliminating variables from those, saved into auto.
   Multi-threaded environment support.
8  Conclusions
In this work we describe design and implementation of a library that brings pattern matching facilities similar to those of functional programming languages into C++. Our solution does not requre any changes to the compiler and in its main part can be implemented in the standard C++98. Several extensions might require use of C++0x features, readily available in todays mainstream compilers. The solution is non-intrusive and can be applied to any given class taxonomy retroactively. Its main utility lays in avoiding the control inversion problem typical to Visitor Design Pattern, which results in more clear, direct and much more consciece code. Our evaluation demonstrates that the solution scales to real-sized projects, while the performance results show that it comes close to its hand-crafted visitor alternative. The main novelty of the paper is in generalizing Haskell’s n+k patterns to any invertible operations and demonstrating how to do it generically in a library setting. Backward semantics of expression templates used to implement this feature is also to the best of our knowledge first application of backward semantics to expression templates.
9  ToDo
•	Separate sequential, random, repetitive into separate test programs and make one that combines them all. This is to test PGO effectiveness. 
•	Proof that recomputations of irrelevant won’t be done forever and will stabilize 
•	Instrument existing apps to see VTBL behavior 
•	Finish experimenting with congruence hierarchy 
•	Justification/proof from Itanium ABI for our approach 
•	Multiple dispatch switch 
•	Different values of the same dynamic type 
•	FIX: Value that would match type but wouldn’t match condition may slow down execution significantly. We need exit from switch instead of fall through 
•	Lock-free version to be used in multi-threaded environments. 
•	Emir’s PhD thesis has measurements, compare to those. 
Discuss: Separating matching arguments from selector prevents us from optimizing for some obvious but typical cases when type 
   Discuss: Visual C++ seems to generate better visitors code: 185 vs 222 units for GCC. GCC seems to generate better matching code: 208 vs 209 units for Visual C++. 64 bit code in Visual C++ actually becomes faster: 143(x64) vs 185(w32) for visitors and 196(x64) vs 209(w32) for pattern matching. We can’t at the moment generate 64bit GCC code. Unlike GCC, we could not find a way to do branch hinting for Visual C++.
   MS Visual C++ 10
   32 — Visitors — Matching 64 — Visitors — Matching -------------------------- -------------------------- SEQ — 185 — 209 SEQ — 145 — 190 RND — 186 — 208 RND — 143 — 196 
   GCC 4.5.2
   32 — Visitors — Matching 64 — Visitors — Matching -------------------------- -------------------------- SEQ — 215 — 189 SEQ — — RND — 222 — 208 RND — — 
10  Acknowledgements
Gregory Berkolaiko for entropy idea. Jaakko Jarvi for Haskell help. Andrew Sutton for suggestions. Jasson Cassey for branch hinting. Mani Zandifar for PAPI help.
11  Scratch
References
[1]	: .
[2]	(2007): clang: a C language family frontend for LLVM. http://clang.llvm.org/.
[3]	R. M. Burstall (1969): Proving Properties of Programs by Structural Induction. Computer Journal .
[4]	R. M. Burstall, D. B. MacQueen & D. T. Sannella (1980): HOPE: An experimental applicative language. In: Proceedings of the 1980 ACM conference on LISP and functional programming, LFP ’80, ACM, New York, NY, USA, pp. 136–143, doi:http://doi.acm.org/10.1145/800087.802799. Available at http://doi.acm.org/10.1145/800087.802799.
[5]	W. Burton, E. Meijer, P. Sansom, S. Thompson & P. Wadler (1996): Views: an extension to haskell pattern matching .
[6]	Stephen Cook, Damian Dechev & Peter Pirkelbauer (2004): The IPR Query Language. Technical Report, Texas A&M University. Available at http://parasol.tamu.edu/pivot/.
[7]	Sy Don, Gregory Neverov & James Margetson (2007): Extensible pattern matching via a lightweight language extension. In: Proceedings of the 12th ACM SIGPLAN international conference on Functional programming, ICFP ’07, ACM, New York, NY, USA, pp. 29–40, doi:http://doi.acm.org/10.1145/1291151.1291159. Available at http://doi.acm.org/10.1145/1291151.1291159.
[8]	Gabriel Dos Reis & Jaakko J?rvi (2005): What is Generic Programming?  In: Proceedings of the First International Workshop of Library-Centric Software Design (LCSD ’05). An OOPSLA ’05 workshop.
[9]	Simon Marlow (editor) (2010): Haskell 2010 Language Report. http://www.haskell.org/onlinereport/haskell2010/.
[10]	Burak Emir (2007): Object-oriented pattern matching. Ph.D. thesis, Lausanne, doi:10.5075/epfl-thesis-3899. Available at http://library.epfl.ch/theses/? nr=3899.
[11]	D. J. Farber, R. E. Griswold & I. P. Polonsky (1964): SNOBOL , A String Manipulation Language. J. ACM 11, pp. 21–30, doi:http://doi.acm.org/10.1145/321203.321207. Available at http://doi.acm.org/10.1145/321203.321207.
[12]	Erich Gamma, Richard Helm, Ralph E. Johnson & John M. Vlissides (1993): Design Patterns: Abstraction and Reuse of Object-Oriented Design. In: Proceedings of the 7th European Conference on Object-Oriented Programming, ECOOP ’93, Springer-Verlag, London, UK, UK, pp. 406–431. Available at http://portal.acm.org/citation.cfm? id=646151.679366.
[13]	J.F. Gimpel (1971): The theory and implementation of pattern matching in SNOBOL4 and other programming languages Bibliography of Numbered SNOBOL4 Documents.
[14]	(2009): Extensible datatypes. http://www.haskell.org/haskellwiki/Extensible_datatypes.
[15]	(2011): Working Draft, Standard for Programming Language C++. Technical Report N3291=11-0061, ISO/IEC JTC 1, Information Technology, Subcommittee SC 22, Programming Language C++. Available at http://www.open-std.org/JTC1/sc22/wg21/prot/14882fdis/n3291.pdf.
[16]	Simon Peyton Jones, editor (2003): Haskell 98 Language and Libraries – The Revised Report. Cambridge University Press, Cambridge, England.
[17]	Shriram Krishnamurthi, Matthias Felleisen & Daniel Friedman (1998): Synthesizing object-oriented and functional design to promote re-use. In Eric Jul, editor: ECOOP’98 - Object-Oriented Programming, Lecture Notes in Computer Science 1445, Springer Berlin / Heidelberg, pp. 91–113. Available at http://dx.doi.org/10.1007/BFb0054088. 10.1007/BFb0054088.
[18]	Keunwoo Lee, Anthony LaMarca & Craig Chambers (2003): HydroJ: object-oriented pattern matching for evolvable distributed systems. In: Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications, OOPSLA ’03, ACM, New York, NY, USA, pp. 205–223, doi:http://doi.acm.org/10.1145/949305.949324. Available at http://doi.acm.org/10.1145/949305.949324.
[19]	Allen Leung (1996): Prop: A C++ based Pattern Matching Language. Technical Report, Courant Institute of Mathematical Sciences, New York University. Available at http://www.cs.nyu.edu/leunga/prop.html.
[20]	Jed Liu & Andrew C. Myers (2003): JMatch: Iterable Abstract Pattern Matching for Java. In: Proceedings of the 5th International Symposium on Practical Aspects of Declarative Languages, PADL ’03, Springer-Verlag, London, UK, UK, pp. 110–127. Available at http://portal.acm.org/citation.cfm? id=645773.668088.
[21]	Andres L?h & Ralf Hinze (2006): Open data types and open functions. In: Proceedings of the 8th ACM SIGPLAN international conference on Principles and practice of declarative programming, PPDP ’06, ACM, New York, NY, USA, pp. 133–144, doi:http://doi.acm.org/10.1145/1140335.1140352. Available at http://doi.acm.org/10.1145/1140335.1140352.
[22]	Microsoft Research (2005): Phoenix Compiler and Shared Source Common Language Infrastructure. http://research.microsoft.com/phoenix/.
[23]	Bartosz Milewski (2011): Haskell - The Pseudocode Language for C++ Template Metaprogramming. In: BoostCon’11. Available at http://boostcon.boost.org/2011-resources.
[24]	Dawn Miller (2010): Pattern Matching. Technical Report, California State University Northridge. Available at http://www.bruce-shapiro.net/math382/Projects/content/Pattern%20Matching%20Final.pdf.
[25]	Robin Milner, Mads Tofte & Robert Harper (1990): The Definition of Standard ML. MIT Press, Cambridge, MA, USA.
[26]	Martin Odersky, Vincent Cremet, Iulian Dragos, Gilles Dubochet, Burak Emir, Sean Mcdirmid, Stephane Micheloud, Nikolay Mihaylov, Michel Schinz, Erik Stenman, Lex Spoon & Matthias Zenger (2006): An overview of the Scala programming language (second edition. Technical Report LAMP-REPORT-2006-001, Ecole Polytechnique Federale de Lausanne.
[27]	Martin Odersky & Philip Wadler (1997): Pizza into Java: Translating theory into practice. In: In Proc. 24th ACM Symposium on Principles of Programming Languages, ACM Press, pp. 146–159.
[28]	Chris Okasaki (1998): Views for Standard ML. In: Workshop on ML.
[29]	Simon Peyton Jones et al. (2003): The Haskell 98 Language and Libraries: The Revised Report. Journal of Functional Programming 13(1), pp. 0–255. http://www.haskell.org/definition/.
[30]	Peter Pirkelbauer (2010): Programming Language Evolution and Source Code Rejuvenation. Ph.D. thesis, Texas A&M University. Available at http://repository.tamu.edu/handle/1969.1/ETD-TAMU-2010-12-8894.
[31]	Gabriel Dos Reis & Bjarne Stroustrup (2009): A Principled, Complete, and Efficient Representation of C++. In: Proc. Joint Conference of ASCM 2009 and MACIS 2009, COE Lecture Notes 22, pp. 407–421.
[32]	Michael R"uegg (2010): Pattern Matching in Scala. Technical Report, University of Applied Sciences Rapperswil. Available at http://www.michaelrueegg.name/doc/papers/pattern_matching_in_scala.pdf.
[33]	Sukyoung Ryu, Changhee Park & Guy L Steele Jr (2010): Adding Pattern Matching to Existing Object-Oriented Languages. In: 2010 International Workshop on Foundations of Object-Oriented Languages. Available at http://ecee.colorado.edu/ siek/FOOL2010/ryu.pdf.
[34]	David Sankel (2010): Algebraic Data Types in C++. Available at http://cpp-next.com/archive/2010/09/algebraic-data-types-in-c/.
[35]	David Sankel (2010): Modern Functional Programming in C++. In: BoostCon’10. Available at http://netsuperbrain.com/gfp/funccpp.pdf.
[36]	Bjarne Stroustrup (2005): A rationale for semantically enhanced library languages. In: LCSD ’05.
[37]	D. A. Turner (1985): Miranda: a non-strict functional language with polymorphic types. In: Proc. of a conference on Functional programming languages and computer architecture, Springer-Verlag New York, Inc., New York, NY, USA, pp. 1–16. Available at http://portal.acm.org/citation.cfm? id=5280.5281.
[38]	Todd Veldhuizen (1995): Expression Templates. C++ Report 7, pp. 26–31.
[39]	Todd L. Veldhuizen (2003): C++ Templates are Turing complete. www.osl.iu.edu/ tveldhui/papers/2003/turing.pdf.
[40]	P. Wadler (1987): Views: a way for pattern matching to cohabit with data abstraction. In: Proceedings of the 14th ACM SIGACT-SIGPLAN symposium on Principles of programming languages, POPL ’87, ACM, New York, NY, USA, pp. 307–313, doi:http://doi.acm.org/10.1145/41625.41653. Available at http://doi.acm.org/10.1145/41625.41653.
[41]	Matthias Zenger & Martin Odersky (2001): Extensible algebraic datatypes with defaults. In: Proceedings of the sixth ACM SIGPLAN international conference on Functional programming, ICFP ’01, ACM, New York, NY, USA, pp. 241–252, doi:http://doi.acm.org/10.1145/507635.507665. Available at http://doi.acm.org/10.1145/507635.507665.
1 Definitions of obvious functions left and right have been ommitted in both cases.
2 We use Wadler’s original paper syntax for this example
---------------

------------------------------------------------------------

---------------

------------------------------------------------------------

 

