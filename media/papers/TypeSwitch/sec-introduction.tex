\section{Introduction} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:intro}

%Motivate the problem
%Give a summary of the paper: what you did and how
%Explicitly state your contribution

Algebraic data types as seen in functional languages are closed, while their 
variants are disjoint. This allows for easy addition of new functions through 
case analysis as well as their efficient implementation. Data types in 
object-oriented languages are extensible and hierarchical (non-disjoint), which 
significantly complicates the addition of new functions. Existing approaches to 
case analysis on such types are either efficient or open, but not both. Truly 
open approaches, which allow for independent extensibility, modular 
type-checking and dynamic linking, rely on type testing through an 
\code{instanceof}-like predicate combined with a decision tree. Efficient 
approaches rely on sealing either the class hierarchy or the set of functions, 
which looses extensibility. Consider for example a simple expression language: 

\begin{lstlisting}
@$exp$ \is{} $val$ \Alt{} $exp+exp$ \Alt{} $exp-exp$ \Alt{} $exp*exp$ \Alt{} $exp/exp$@
\end{lstlisting}

\noindent 
In an object-oriented language without direct support for algebraic data types, 
the type representing an expression-tree in the language will typically be 
encoded as an abstract base class, listing the (sealed set of) allowed virtual 
functions, with derived classes representing variants:

\begin{lstlisting}[keepspaces,columns=flexible]
struct Expr { virtual @$\sim$@Expr() {} };
struct Value  : Expr { int value; };
struct Plus   : Expr { Expr* e1; Expr* e2; };
struct Minus; struct Times; struct Divide; // similarly
\end{lstlisting}

\noindent
A simple evaluator for this language can be implemented through a virtual 
function \code{virtual int eval() const = 0;} introduced into the base class. 
While extremely efficient, the approach is \emph{intrusive}, as we will have to 
modify the base class every time we would like to add a function. 
A less-intrusive solution to the extensibility of functions can be achieved with 
\emph{visitor design pattern}~\cite{DesignPatterns1993}. The solution, however, 
is not open as it restricts extensibility of classes.

Our truly open solution overcomes extensibility problems of both functions and 
types by allowing external introspection of objects with pattern matching:

\begin{lstlisting}[keepspaces,columns=flexible]
int eval(const Expr* e)
{
  Match(e)
    Case(Value,  n)    return n;
    Case(Plus,   a, b) return eval(a) + eval(b);
    Case(Minus,  a, b) return eval(a) - eval(b);
    Case(Times,  a, b) return eval(a) * eval(b);
    Case(Divide, a, b) return eval(a) / eval(b);
  EndMatch
}
\end{lstlisting}

\noindent
The syntax is provided without any external tool support. Instead we rely on a 
few C++0x features~\cite{C++0x}, template meta-programming, and macros. As shown 
in section~\ref{sec:eval}, it runs about as fast as the OCaml version, and, 
depending on the usage scenario, compiler and underlying hardware, comes close 
or outperforms the handcrafted C++ code based on the \emph{visitor design pattern}.
The mapping of members to matching positions that the user has to provide to 
make the above example fully functional is omitted~\cite{TR}.

\subsection{Summary}

We present techniques that can be used to implement type switching efficiently 
based on the run-time type of the argument.

  \begin{itemize}
  \setlength{\itemsep}{0pt}
  \setlength{\parskip}{0pt}
  \item The techniques outperform its de facto contender -- visitor design 
        pattern -- without sacrificing extensibility.
  \item They work in the presence of multiple inheritance, including repeated and 
        virtual inheritance, as well as in generic code.
  \item The solution is open, non-intrusive, and avoids the control inversion 
        typical for visitors. 
  \item It applies to polymorphic and tagged class hierarchies through a unified 
        syntax. 
  \item The technique generalizes to other languages and can be used to 
        implement type switching, type testing, predicate dispatch, and 
        multi-methods efficiently.
  \end{itemize}

\noindent
A practical benefit of our solution is that it can be used right away with any 
compiler with a descent support of C++0x without requiring the installation of 
any additional tools or preprocessors. The solution is a proof of concept that 
sets a minimum threshold for the performance, brevity, clarity and usefulness of 
a language solution for open type switching in C++.

Due to page restrictions, we will only deal here with the part of the library 
concerned with efficient type testing, type identification, and type switching. 
These primitive operations are essential in providing support for type patterns 
and constructor patterns, while their efficiency relative to the visitor design 
pattern might become a major argument for their adoption. We refer the reader to 
accompanying paper~\cite{AP} and technical report~\cite{TR} for details on the 
rest of our pattern-matching library.

Section~\ref{sec:probl} will motivate the problem as well as discuss some 
existing solutions and their limitations. Section~\ref{sec:copc} will outline 
the three techniques that comprise our solution, while the 
section~\ref{sec:eval} will evaluate their performance. Related work is 
discussed in Section~\ref{sec:rw}, followed by concluding remarks in 
Section~\ref{sec:cc}.
