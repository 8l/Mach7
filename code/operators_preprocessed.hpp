#if defined(__GNUC__)
template <typename E1> inline auto operator-(E1&& e1) noexcept -> typename std::enable_if<is_expression<E1>::value, typename filtered_result<negation,       E1>::type >::type { return make_expr<negation>       (filter(std::forward<E1>(e1))); }
template <typename E1> inline auto operator~(E1&& e1) noexcept -> typename std::enable_if<is_expression<E1>::value, typename filtered_result<bit_complement, E1>::type >::type { return make_expr<bit_complement> (filter(std::forward<E1>(e1))); }
template <typename E1> inline auto operator!(E1&& e1) noexcept -> typename std::enable_if<is_expression<E1>::value, typename filtered_result<bool_complement,E1>::type >::type { return make_expr<bool_complement>(filter(std::forward<E1>(e1))); }

template <typename E1, typename E2> inline auto operator+ (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value,     typename filtered_result<addition,       E1,E2>::type >::type { return make_expr<addition>       (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator- (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<subtraction,    E1,E2>::type >::type { return make_expr<subtraction>    (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator* (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<multiplication, E1,E2>::type >::type { return make_expr<multiplication> (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator/ (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<division,       E1,E2>::type >::type { return make_expr<division>       (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator% (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<modulo,         E1,E2>::type >::type { return make_expr<modulo>         (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator& (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<bit_and,        E1,E2>::type >::type { return make_expr<bit_and>        (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator| (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<bit_or,         E1,E2>::type >::type { return make_expr<bit_or>         (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator^ (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<bit_xor,        E1,E2>::type >::type { return make_expr<bit_xor>        (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator<<(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<bit_shift_left, E1,E2>::type >::type { return make_expr<bit_shift_left> (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator>>(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<bit_shift_right,E1,E2>::type >::type { return make_expr<bit_shift_right>(filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator&&(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<bool_and,       E1,E2>::type >::type { return make_expr<bool_and>       (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
//template <typename E1, typename E2> inline auto operator||(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<bool_or,        E1,E2>::type >::type { return make_expr<bool_or>        (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator==(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<equal,          E1,E2>::type >::type { return make_expr<equal>          (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator!=(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<not_equal,      E1,E2>::type >::type { return make_expr<not_equal>      (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator> (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<greater,        E1,E2>::type >::type { return make_expr<greater>        (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator>=(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<greater_equal,  E1,E2>::type >::type { return make_expr<greater_equal>  (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator< (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<less,           E1,E2>::type >::type { return make_expr<less>           (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator<=(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, typename filtered_result<less_equal,     E1,E2>::type >::type { return make_expr<less_equal>     (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
#endif

#if !defined(__GNUC__)

template <typename E1> inline auto operator-(E1&& e1) noexcept -> typename std::enable_if<is_expression<E1>::value, expr<negation,       decltype(filter(std::forward<E1>(e1)))> >::type { return make_expr<negation>       (filter(std::forward<E1>(e1))); }
template <typename E1> inline auto operator~(E1&& e1) noexcept -> typename std::enable_if<is_expression<E1>::value, expr<bit_complement, decltype(filter(std::forward<E1>(e1)))> >::type { return make_expr<bit_complement> (filter(std::forward<E1>(e1))); }
template <typename E1> inline auto operator!(E1&& e1) noexcept -> typename std::enable_if<is_expression<E1>::value, expr<bool_complement,decltype(filter(std::forward<E1>(e1)))> >::type { return make_expr<bool_complement>(filter(std::forward<E1>(e1))); }

template <typename E1, typename E2> inline auto operator+ (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<addition,       decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<addition>       (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator- (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<subtraction,    decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<subtraction>    (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator* (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<multiplication, decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<multiplication> (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator/ (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<division,       decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<division>       (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator% (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<modulo,         decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<modulo>         (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator& (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<bit_and,        decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<bit_and>        (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator| (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<bit_or,         decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<bit_or>         (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator^ (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<bit_xor,        decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<bit_xor>        (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator<<(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<bit_shift_left, decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<bit_shift_left> (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator>>(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<bit_shift_right,decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<bit_shift_right>(filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator&&(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<bool_and,       decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<bool_and>       (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
//template <typename E1, typename E2> inline auto operator||(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<bool_or,        decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<bool_or>        (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator==(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<equal,          decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<equal>          (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator!=(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<not_equal,      decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<not_equal>      (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator> (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<greater,        decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<greater>        (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator>=(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<greater_equal,  decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<greater_equal>  (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator< (E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<less,           decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<less>           (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }
template <typename E1, typename E2> inline auto operator<=(E1&& e1, E2&& e2) noexcept -> typename std::enable_if<either_is_expression<E1,E2>::value, expr<less_equal,     decltype(filter(std::forward<E1>(e1))),decltype(filter(std::forward<E2>(e2)))> >::type { return make_expr<less_equal>     (filter(std::forward<E1>(e1)),filter(std::forward<E2>(e2))); }

#else

//template <typename T>                            inline auto operator-( variable<T>& v) noexcept -> decltype(make_expr<negation>(var_ref<variable<T>>(v))) { return /*(*/make_expr<negation>(var_ref<variable<T>>(v))/*)*/; }
//template <typename T>                            inline auto operator-(const value<T>& v) noexcept -> decltype(make_expr<negation>(v)) { return /*(*/make_expr<negation>(v)/*)*/; }
//template <typename F1, typename E1>              inline auto operator-(const expr<F1,E1>& v) noexcept -> decltype(make_expr<negation>(v)) { return /*(*/make_expr<negation>(v)/*)*/; }
//template <typename F1, typename E1, typename E2> inline auto operator-(const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<negation>(v)) { return /*(*/make_expr<negation>(v)/*)*/; }
//template <typename T>                            inline auto operator~( variable<T>& v) noexcept -> decltype(make_expr<bit_complement>(var_ref<variable<T>>(v))) { return /*(*/make_expr<bit_complement>(var_ref<variable<T>>(v))/*)*/; }
//template <typename T>                            inline auto operator~(const value<T>& v) noexcept -> decltype(make_expr<bit_complement>(v)) { return /*(*/make_expr<bit_complement>(v)/*)*/; }
//template <typename F1, typename E1>              inline auto operator~(const expr<F1,E1>& v) noexcept -> decltype(make_expr<bit_complement>(v)) { return /*(*/make_expr<bit_complement>(v)/*)*/; }
//template <typename F1, typename E1, typename E2> inline auto operator~(const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<bit_complement>(v)) { return /*(*/make_expr<bit_complement>(v)/*)*/; }
//template <typename T>                            inline auto operator!( variable<T>& v) noexcept -> decltype(make_expr<bool_complement>(var_ref<variable<T>>(v))) { return /*(*/make_expr<bool_complement>(var_ref<variable<T>>(v))/*)*/; }
//template <typename T>                            inline auto operator!(const value<T>& v) noexcept -> decltype(make_expr<bool_complement>(v)) { return /*(*/make_expr<bool_complement>(v)/*)*/; }
//template <typename F1, typename E1>              inline auto operator!(const expr<F1,E1>& v) noexcept -> decltype(make_expr<bool_complement>(v)) { return /*(*/make_expr<bool_complement>(v)/*)*/; }
//template <typename F1, typename E1, typename E2> inline auto operator!(const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<bool_complement>(v)) { return /*(*/make_expr<bool_complement>(v)/*)*/; }

//template <typename T, typename E>                             inline auto operator+( variable<T>& v, E&& e) noexcept -> decltype(make_expr<addition>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<addition>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator+( E&& e, variable<T>& v) noexcept -> expr<addition,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<addition>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator+(const value<T>& v, E&& e) noexcept -> decltype(make_expr<addition>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<addition>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator+( E&& e, const value<T>& v) noexcept -> decltype(make_expr<addition>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<addition>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator+(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<addition>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<addition>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator+( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<addition>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<addition>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator+(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<addition>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<addition>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator+( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<addition>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<addition>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator+(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<addition>(v,c)) { return /*(*/make_expr<addition>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator+( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<addition>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<addition>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator+(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<addition>(a,b)) { return /*(*/make_expr<addition>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator+( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<addition>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<addition>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator+(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<addition>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<addition>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator+(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<addition>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<addition>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator+( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<addition>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<addition>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator+(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<addition>(e,c)) { return /*(*/make_expr<addition>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator+(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<addition>(c,e)) { return /*(*/make_expr<addition>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator-( variable<T>& v, E&& e) noexcept -> decltype(make_expr<subtraction>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<subtraction>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator-( E&& e, variable<T>& v) noexcept -> expr<subtraction,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<subtraction>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator-(const value<T>& v, E&& e) noexcept -> decltype(make_expr<subtraction>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<subtraction>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator-( E&& e, const value<T>& v) noexcept -> decltype(make_expr<subtraction>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<subtraction>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator-(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<subtraction>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<subtraction>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator-( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<subtraction>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<subtraction>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator-(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<subtraction>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<subtraction>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator-( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<subtraction>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<subtraction>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator-(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<subtraction>(v,c)) { return /*(*/make_expr<subtraction>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator-( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<subtraction>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<subtraction>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator-(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<subtraction>(a,b)) { return /*(*/make_expr<subtraction>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator-( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<subtraction>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<subtraction>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator-(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<subtraction>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<subtraction>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator-(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<subtraction>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<subtraction>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator-( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<subtraction>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<subtraction>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator-(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<subtraction>(e,c)) { return /*(*/make_expr<subtraction>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator-(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<subtraction>(c,e)) { return /*(*/make_expr<subtraction>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator*( variable<T>& v, E&& e) noexcept -> expr<multiplication,var_ref<variable<T>>,decltype(filter(std::forward<E>(e)))> { return /*(*/make_expr<multiplication>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator*( E&& e, variable<T>& v) noexcept -> expr<multiplication,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<multiplication>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator*(const value<T>& v, E&& e) noexcept -> decltype(make_expr<multiplication>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<multiplication>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator*( E&& e, const value<T>& v) noexcept -> decltype(make_expr<multiplication>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<multiplication>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator*(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<multiplication>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<multiplication>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator*( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<multiplication>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<multiplication>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator*(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<multiplication>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<multiplication>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator*( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<multiplication>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<multiplication>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator*(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<multiplication>(v,c)) { return /*(*/make_expr<multiplication>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator*( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<multiplication>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<multiplication>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator*(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<multiplication>(a,b)) { return /*(*/make_expr<multiplication>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator*( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<multiplication>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<multiplication>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator*(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<multiplication>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<multiplication>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator*(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<multiplication>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<multiplication>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator*( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<multiplication>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<multiplication>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator*(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<multiplication>(e,c)) { return /*(*/make_expr<multiplication>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator*(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<multiplication>(c,e)) { return /*(*/make_expr<multiplication>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator/( variable<T>& v, E&& e) noexcept -> decltype(make_expr<division>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<division>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator/( E&& e, variable<T>& v) noexcept -> expr<division,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<division>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator/(const value<T>& v, E&& e) noexcept -> decltype(make_expr<division>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<division>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator/( E&& e, const value<T>& v) noexcept -> decltype(make_expr<division>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<division>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator/(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<division>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<division>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator/( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<division>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<division>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator/(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<division>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<division>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator/( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<division>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<division>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator/(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<division>(v,c)) { return /*(*/make_expr<division>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator/( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<division>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<division>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator/(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<division>(a,b)) { return /*(*/make_expr<division>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator/( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<division>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<division>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator/(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<division>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<division>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator/(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<division>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<division>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator/( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<division>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<division>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator/(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<division>(e,c)) { return /*(*/make_expr<division>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator/(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<division>(c,e)) { return /*(*/make_expr<division>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator%( variable<T>& v, E&& e) noexcept -> decltype(make_expr<modulo>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<modulo>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator%( E&& e, variable<T>& v) noexcept -> expr<modulo,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<modulo>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator%(const value<T>& v, E&& e) noexcept -> decltype(make_expr<modulo>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<modulo>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator%( E&& e, const value<T>& v) noexcept -> decltype(make_expr<modulo>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<modulo>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator%(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<modulo>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<modulo>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator%( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<modulo>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<modulo>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator%(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<modulo>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<modulo>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator%( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<modulo>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<modulo>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator%(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<modulo>(v,c)) { return /*(*/make_expr<modulo>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator%( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<modulo>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<modulo>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator%(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<modulo>(a,b)) { return /*(*/make_expr<modulo>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator%( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<modulo>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<modulo>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator%(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<modulo>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<modulo>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator%(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<modulo>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<modulo>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator%( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<modulo>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<modulo>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator%(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<modulo>(e,c)) { return /*(*/make_expr<modulo>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator%(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<modulo>(c,e)) { return /*(*/make_expr<modulo>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator&( variable<T>& v, E&& e) noexcept -> decltype(make_expr<bit_and>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_and>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator&( E&& e, variable<T>& v) noexcept -> expr<bit_and,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<bit_and>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator&(const value<T>& v, E&& e) noexcept -> decltype(make_expr<bit_and>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_and>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator&( E&& e, const value<T>& v) noexcept -> decltype(make_expr<bit_and>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bit_and>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator&(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<bit_and>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_and>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator&( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<bit_and>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bit_and>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator&(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<bit_and>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_and>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator&( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<bit_and>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bit_and>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator&(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<bit_and>(v,c)) { return /*(*/make_expr<bit_and>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator&( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<bit_and>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<bit_and>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator&(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<bit_and>(a,b)) { return /*(*/make_expr<bit_and>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator&( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<bit_and>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<bit_and>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator&(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<bit_and>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<bit_and>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<bit_and>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<bit_and>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<bit_and>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<bit_and>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<bit_and>(e,c)) { return /*(*/make_expr<bit_and>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<bit_and>(c,e)) { return /*(*/make_expr<bit_and>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator|( variable<T>& v, E&& e) noexcept -> decltype(make_expr<bit_or>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_or>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator|( E&& e, variable<T>& v) noexcept -> expr<bit_or,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<bit_or>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator|(const value<T>& v, E&& e) noexcept -> decltype(make_expr<bit_or>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_or>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator|( E&& e, const value<T>& v) noexcept -> decltype(make_expr<bit_or>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bit_or>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator|(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<bit_or>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_or>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator|( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<bit_or>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bit_or>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator|(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<bit_or>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_or>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator|( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<bit_or>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bit_or>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator|(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<bit_or>(v,c)) { return /*(*/make_expr<bit_or>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator|( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<bit_or>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<bit_or>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator|(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<bit_or>(a,b)) { return /*(*/make_expr<bit_or>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator|( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<bit_or>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<bit_or>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator|(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<bit_or>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<bit_or>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator|(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<bit_or>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<bit_or>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator|( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<bit_or>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<bit_or>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator|(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<bit_or>(e,c)) { return /*(*/make_expr<bit_or>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator|(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<bit_or>(c,e)) { return /*(*/make_expr<bit_or>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator^( variable<T>& v, E&& e) noexcept -> decltype(make_expr<bit_xor>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_xor>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator^( E&& e, variable<T>& v) noexcept -> expr<bit_xor,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<bit_xor>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator^(const value<T>& v, E&& e) noexcept -> decltype(make_expr<bit_xor>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_xor>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator^( E&& e, const value<T>& v) noexcept -> decltype(make_expr<bit_xor>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bit_xor>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator^(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<bit_xor>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_xor>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator^( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<bit_xor>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bit_xor>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator^(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<bit_xor>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_xor>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator^( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<bit_xor>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bit_xor>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator^(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<bit_xor>(v,c)) { return /*(*/make_expr<bit_xor>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator^( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<bit_xor>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<bit_xor>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator^(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<bit_xor>(a,b)) { return /*(*/make_expr<bit_xor>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator^( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<bit_xor>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<bit_xor>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator^(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<bit_xor>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<bit_xor>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator^(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<bit_xor>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<bit_xor>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator^( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<bit_xor>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<bit_xor>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator^(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<bit_xor>(e,c)) { return /*(*/make_expr<bit_xor>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator^(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<bit_xor>(c,e)) { return /*(*/make_expr<bit_xor>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator<<( variable<T>& v, E&& e) noexcept -> decltype(make_expr<bit_shift_left>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_shift_left>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator<<( E&& e, variable<T>& v) noexcept -> expr<bit_shift_left,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<bit_shift_left>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator<<(const value<T>& v, E&& e) noexcept -> decltype(make_expr<bit_shift_left>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_shift_left>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator<<( E&& e, const value<T>& v) noexcept -> decltype(make_expr<bit_shift_left>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bit_shift_left>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator<<(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<bit_shift_left>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_shift_left>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator<<( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<bit_shift_left>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bit_shift_left>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator<<(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<bit_shift_left>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_shift_left>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator<<( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<bit_shift_left>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bit_shift_left>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator<<(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<bit_shift_left>(v,c)) { return /*(*/make_expr<bit_shift_left>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator<<( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<bit_shift_left>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<bit_shift_left>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator<<(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<bit_shift_left>(a,b)) { return /*(*/make_expr<bit_shift_left>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator<<( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<bit_shift_left>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<bit_shift_left>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator<<(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<bit_shift_left>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<bit_shift_left>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<<(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<bit_shift_left>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<bit_shift_left>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<<( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<bit_shift_left>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<bit_shift_left>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<<(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<bit_shift_left>(e,c)) { return /*(*/make_expr<bit_shift_left>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<<(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<bit_shift_left>(c,e)) { return /*(*/make_expr<bit_shift_left>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator>>( variable<T>& v, E&& e) noexcept -> decltype(make_expr<bit_shift_right>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_shift_right>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator>>( E&& e, variable<T>& v) noexcept -> expr<bit_shift_right,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<bit_shift_right>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator>>(const value<T>& v, E&& e) noexcept -> decltype(make_expr<bit_shift_right>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_shift_right>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator>>( E&& e, const value<T>& v) noexcept -> decltype(make_expr<bit_shift_right>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bit_shift_right>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator>>(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<bit_shift_right>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_shift_right>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator>>( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<bit_shift_right>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bit_shift_right>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator>>(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<bit_shift_right>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bit_shift_right>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator>>( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<bit_shift_right>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bit_shift_right>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator>>(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<bit_shift_right>(v,c)) { return /*(*/make_expr<bit_shift_right>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator>>( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<bit_shift_right>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<bit_shift_right>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator>>(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<bit_shift_right>(a,b)) { return /*(*/make_expr<bit_shift_right>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator>>( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<bit_shift_right>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<bit_shift_right>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator>>(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<bit_shift_right>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<bit_shift_right>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>>(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<bit_shift_right>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<bit_shift_right>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>>( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<bit_shift_right>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<bit_shift_right>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>>(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<bit_shift_right>(e,c)) { return /*(*/make_expr<bit_shift_right>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>>(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<bit_shift_right>(c,e)) { return /*(*/make_expr<bit_shift_right>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator&&( variable<T>& v, E&& e) noexcept -> decltype(make_expr<bool_and>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<bool_and>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator&&( E&& e, variable<T>& v) noexcept -> expr<bool_and,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<bool_and>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator&&(const value<T>& v, E&& e) noexcept -> decltype(make_expr<bool_and>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bool_and>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator&&( E&& e, const value<T>& v) noexcept -> decltype(make_expr<bool_and>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bool_and>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator&&(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<bool_and>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bool_and>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator&&( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<bool_and>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bool_and>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator&&(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<bool_and>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bool_and>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator&&( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<bool_and>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bool_and>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator&&(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<bool_and>(v,c)) { return /*(*/make_expr<bool_and>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator&&( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<bool_and>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<bool_and>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator&&(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<bool_and>(a,b)) { return /*(*/make_expr<bool_and>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator&&( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<bool_and>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<bool_and>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator&&(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<bool_and>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<bool_and>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&&(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<bool_and>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<bool_and>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&&( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<bool_and>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<bool_and>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&&(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<bool_and>(e,c)) { return /*(*/make_expr<bool_and>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator&&(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<bool_and>(c,e)) { return /*(*/make_expr<bool_and>(c,e)/*)*/; }
template <typename T, typename E>                             inline auto operator||( variable<T>& v, E&& e) noexcept -> decltype(make_expr<bool_or>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<bool_or>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
template <typename T, typename E>                             inline auto operator||( E&& e, variable<T>& v) noexcept -> expr<bool_or,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<bool_or>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
template <typename T, typename E>                             inline auto operator||(const value<T>& v, E&& e) noexcept -> decltype(make_expr<bool_or>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bool_or>(v,filter(std::forward<E>(e)))/*)*/; }
template <typename T, typename E>                             inline auto operator||( E&& e, const value<T>& v) noexcept -> decltype(make_expr<bool_or>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bool_or>(filter(std::forward<E>(e)),v)/*)*/; }
template <typename F1, typename E1, typename E>               inline auto operator||(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<bool_or>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bool_or>(v,filter(std::forward<E>(e)))/*)*/; }
template <typename F1, typename E1, typename E>               inline auto operator||( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<bool_or>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bool_or>(filter(std::forward<E>(e)),v)/*)*/; }
template <typename F1, typename E1, typename E2, typename E>  inline auto operator||(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<bool_or>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<bool_or>(v,filter(std::forward<E>(e)))/*)*/; }
template <typename F1, typename E1, typename E2, typename E>  inline auto operator||( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<bool_or>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<bool_or>(filter(std::forward<E>(e)),v)/*)*/; }
template <typename T, typename U>                             inline auto operator||(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<bool_or>(v,c)) { return /*(*/make_expr<bool_or>(v,c)/*)*/; }
template <typename T, typename U>                             inline auto operator||( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<bool_or>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<bool_or>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator||(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<bool_or>(a,b)) { return /*(*/make_expr<bool_or>(a,b)/*)*/; }
template <typename T, typename U>                             inline auto operator||( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<bool_or>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<bool_or>(var_ref<variable<T>>(v),c)/*)*/; }
template <typename T, typename U>                             inline auto operator||(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<bool_or>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<bool_or>(c,var_ref<variable<T>>(v))/*)*/; }
template <typename T, typename F1, typename E1, typename E2>  inline auto operator||(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<bool_or>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<bool_or>(e,var_ref<variable<T>>(v))/*)*/; }
template <typename T, typename F1, typename E1, typename E2>  inline auto operator||( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<bool_or>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<bool_or>(var_ref<variable<T>>(v),e)/*)*/; }
template <typename T, typename F1, typename E1, typename E2>  inline auto operator||(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<bool_or>(e,c)) { return /*(*/make_expr<bool_or>(e,c)/*)*/; }
template <typename T, typename F1, typename E1, typename E2>  inline auto operator||(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<bool_or>(c,e)) { return /*(*/make_expr<bool_or>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator==( variable<T>& v, E&& e) noexcept -> decltype(make_expr<equal>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<equal>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator==( E&& e, variable<T>& v) noexcept -> expr<equal,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<equal>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator==(const value<T>& v, E&& e) noexcept -> decltype(make_expr<equal>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<equal>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator==( E&& e, const value<T>& v) noexcept -> decltype(make_expr<equal>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<equal>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator==(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<equal>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<equal>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator==( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<equal>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<equal>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator==(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<equal>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<equal>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator==( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<equal>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<equal>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator==(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<equal>(v,c)) { return /*(*/make_expr<equal>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator==( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<equal>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<equal>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator==(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<equal>(a,b)) { return /*(*/make_expr<equal>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator==( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<equal>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<equal>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator==(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<equal>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<equal>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator==(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<equal>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<equal>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator==( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<equal>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<equal>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator==(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<equal>(e,c)) { return /*(*/make_expr<equal>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator==(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<equal>(c,e)) { return /*(*/make_expr<equal>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator!=( variable<T>& v, E&& e) noexcept -> decltype(make_expr<not_equal>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<not_equal>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator!=( E&& e, variable<T>& v) noexcept -> expr<not_equal,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<not_equal>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator!=(const value<T>& v, E&& e) noexcept -> decltype(make_expr<not_equal>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<not_equal>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator!=( E&& e, const value<T>& v) noexcept -> decltype(make_expr<not_equal>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<not_equal>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator!=(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<not_equal>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<not_equal>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator!=( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<not_equal>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<not_equal>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator!=(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<not_equal>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<not_equal>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator!=( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<not_equal>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<not_equal>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator!=(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<not_equal>(v,c)) { return /*(*/make_expr<not_equal>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator!=( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<not_equal>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<not_equal>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator!=(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<not_equal>(a,b)) { return /*(*/make_expr<not_equal>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator!=( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<not_equal>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<not_equal>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator!=(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<not_equal>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<not_equal>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator!=(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<not_equal>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<not_equal>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator!=( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<not_equal>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<not_equal>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator!=(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<not_equal>(e,c)) { return /*(*/make_expr<not_equal>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator!=(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<not_equal>(c,e)) { return /*(*/make_expr<not_equal>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator>( variable<T>& v, E&& e) noexcept -> decltype(make_expr<greater>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<greater>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator>( E&& e, variable<T>& v) noexcept -> expr<greater,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<greater>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator>(const value<T>& v, E&& e) noexcept -> decltype(make_expr<greater>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<greater>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator>( E&& e, const value<T>& v) noexcept -> decltype(make_expr<greater>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<greater>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator>(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<greater>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<greater>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator>( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<greater>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<greater>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator>(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<greater>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<greater>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator>( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<greater>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<greater>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator>(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<greater>(v,c)) { return /*(*/make_expr<greater>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator>( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<greater>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<greater>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator>(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<greater>(a,b)) { return /*(*/make_expr<greater>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator>( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<greater>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<greater>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator>(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<greater>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<greater>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<greater>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<greater>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<greater>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<greater>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<greater>(e,c)) { return /*(*/make_expr<greater>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<greater>(c,e)) { return /*(*/make_expr<greater>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator>=( variable<T>& v, E&& e) noexcept -> decltype(make_expr<greater_equal>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<greater_equal>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator>=( E&& e, variable<T>& v) noexcept -> expr<greater_equal,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<greater_equal>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator>=(const value<T>& v, E&& e) noexcept -> decltype(make_expr<greater_equal>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<greater_equal>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator>=( E&& e, const value<T>& v) noexcept -> decltype(make_expr<greater_equal>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<greater_equal>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator>=(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<greater_equal>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<greater_equal>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator>=( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<greater_equal>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<greater_equal>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator>=(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<greater_equal>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<greater_equal>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator>=( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<greater_equal>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<greater_equal>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator>=(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<greater_equal>(v,c)) { return /*(*/make_expr<greater_equal>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator>=( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<greater_equal>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<greater_equal>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator>=(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<greater_equal>(a,b)) { return /*(*/make_expr<greater_equal>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator>=( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<greater_equal>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<greater_equal>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator>=(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<greater_equal>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<greater_equal>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>=(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<greater_equal>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<greater_equal>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>=( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<greater_equal>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<greater_equal>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>=(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<greater_equal>(e,c)) { return /*(*/make_expr<greater_equal>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator>=(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<greater_equal>(c,e)) { return /*(*/make_expr<greater_equal>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator<( variable<T>& v, E&& e) noexcept -> decltype(make_expr<less>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<less>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator<( E&& e, variable<T>& v) noexcept -> expr<less,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<less>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator<(const value<T>& v, E&& e) noexcept -> decltype(make_expr<less>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<less>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator<( E&& e, const value<T>& v) noexcept -> decltype(make_expr<less>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<less>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator<(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<less>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<less>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator<( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<less>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<less>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator<(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<less>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<less>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator<( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<less>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<less>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator<(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<less>(v,c)) { return /*(*/make_expr<less>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator<( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<less>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<less>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator<(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<less>(a,b)) { return /*(*/make_expr<less>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator<( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<less>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<less>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator<(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<less>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<less>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<less>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<less>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<less>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<less>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<less>(e,c)) { return /*(*/make_expr<less>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<less>(c,e)) { return /*(*/make_expr<less>(c,e)/*)*/; }
//template <typename T, typename E>                             inline auto operator<=( variable<T>& v, E&& e) noexcept -> decltype(make_expr<less_equal>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))) { return /*(*/make_expr<less_equal>(var_ref<variable<T>>(v),filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator<=( E&& e, variable<T>& v) noexcept -> expr<less_equal,decltype(filter(std::forward<E>(e))),var_ref<variable<T>>> { return make_expr<less_equal>(filter(std::forward<E>(e)),var_ref<variable<T>>(v)); }
//template <typename T, typename E>                             inline auto operator<=(const value<T>& v, E&& e) noexcept -> decltype(make_expr<less_equal>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<less_equal>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename T, typename E>                             inline auto operator<=( E&& e, const value<T>& v) noexcept -> decltype(make_expr<less_equal>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<less_equal>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator<=(const expr<F1,E1>& v, E&& e) noexcept -> decltype(make_expr<less_equal>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<less_equal>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E>               inline auto operator<=( E&& e, const expr<F1,E1>& v) noexcept -> decltype(make_expr<less_equal>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<less_equal>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator<=(const expr<F1,E1,E2>& v, E&& e) noexcept -> decltype(make_expr<less_equal>(v,filter(std::forward<E>(e)))) { return /*(*/make_expr<less_equal>(v,filter(std::forward<E>(e)))/*)*/; }
//template <typename F1, typename E1, typename E2, typename E>  inline auto operator<=( E&& e, const expr<F1,E1,E2>& v) noexcept -> decltype(make_expr<less_equal>(filter(std::forward<E>(e)),v)) { return /*(*/make_expr<less_equal>(filter(std::forward<E>(e)),v)/*)*/; }
//template <typename T, typename U>                             inline auto operator<=(const value<T>& v, const value<U>& c) noexcept -> decltype(make_expr<less_equal>(v,c)) { return /*(*/make_expr<less_equal>(v,c)/*)*/; }
//template <typename T, typename U>                             inline auto operator<=( variable<T>& v, variable<U>& w) noexcept -> decltype(make_expr<less_equal>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))) { return /*(*/make_expr<less_equal>(var_ref<variable<T>>(v),var_ref<variable<T>>(w))/*)*/; }
//template <typename F1, typename E1, typename E2, typename F2, typename E3, typename E4>  inline auto operator<=(const expr<F1,E1,E2>& a, const expr<F2,E3,E4>& b) noexcept -> decltype(make_expr<less_equal>(a,b)) { return /*(*/make_expr<less_equal>(a,b)/*)*/; }
//template <typename T, typename U>                             inline auto operator<=( variable<T>& v, const value<U>& c) noexcept -> decltype(make_expr<less_equal>(var_ref<variable<T>>(v),c)) { return /*(*/make_expr<less_equal>(var_ref<variable<T>>(v),c)/*)*/; }
//template <typename T, typename U>                             inline auto operator<=(const value<U>& c, variable<T>& v) noexcept -> decltype(make_expr<less_equal>(c,var_ref<variable<T>>(v))) { return /*(*/make_expr<less_equal>(c,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<=(const expr<F1,E1,E2>& e, variable<T>& v) noexcept -> decltype(make_expr<less_equal>(e,var_ref<variable<T>>(v))) { return /*(*/make_expr<less_equal>(e,var_ref<variable<T>>(v))/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<=( variable<T>& v, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<less_equal>(var_ref<variable<T>>(v),e)) { return /*(*/make_expr<less_equal>(var_ref<variable<T>>(v),e)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<=(const expr<F1,E1,E2>& e, const value<T>& c) noexcept -> decltype(make_expr<less_equal>(e,c)) { return /*(*/make_expr<less_equal>(e,c)/*)*/; }
//template <typename T, typename F1, typename E1, typename E2>  inline auto operator<=(const value<T>& c, const expr<F1,E1,E2>& e) noexcept -> decltype(make_expr<less_equal>(c,e)) { return /*(*/make_expr<less_equal>(c,e)/*)*/; }
#endif
